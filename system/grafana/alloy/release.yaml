---
apiVersion: helm.toolkit.fluxcd.io/v2beta2
kind: HelmRelease
metadata:
  name: alloy

spec:
  interval: 1m
  timeout: 10m
  releaseName: alloy
  chart:
    spec:
      chart: alloy
      version: 0.1.1
      sourceRef:
        kind: HelmRepository
        name: grafana
      interval: 1m
  install:
    remediation:
      retries: 5

  values:
    alloy:
      clustering:
        enabled: true
      configMap:
        content: |-
          logging {
            level = "info"
            format = "logfmt"
          }

          // write destinations
          //
          prometheus.remote_write "mimir" {
            endpoint {
              url = "http://mimir-nginx/api/v1/push"
            }
          }
          loki.write "loki" {
            endpoint {
              url = "http://loki-gateway/loki/api/v1/push"
            }
          }

          // node_exporter metrics
          //
          prometheus.exporter.unix "node_stats" { }
          prometheus.scrape "node_stats" {
            targets    = prometheus.exporter.unix.node_stats.targets
            forward_to = [prometheus.remote_write.mimir.receiver]
          }

          // these next examples come from https://medium.com/@stepanvrany/i-replaced-several-kubernetes-components-with-grafana-agent-flow-heres-how-74ecdc60bffe

          // discover all nodes
          //
          discovery.kubernetes "nodes" {
            role = "node"
          }

          // cadvisor
          //
          discovery.relabel "metrics_cadvisor" {
            targets = discovery.kubernetes.nodes.targets

            rule {
              action = "replace"
              target_label = "__address__"
              replacement = "kubernetes.default.svc.cluster.local:443"
            }

            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              regex = "(.+)"
              action = "replace"
              replacement = "/api/v1/nodes/$${1}/proxy/metrics/cadvisor"
              target_label = "__metrics_path__"
            }
          }
          prometheus.scrape "node" {
            scheme = "https"
            tls_config {
                server_name = "kubernetes"
                ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                insecure_skip_verify = false
            }
            bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
            targets = discovery.relabel.metrics_cadvisor.output
            scrape_interval = "15s"
            forward_to = [prometheus.remote_write.mimir.receiver]
          }

          // kubelet
          //
          discovery.relabel "metrics_kubelet" {
            targets = discovery.kubernetes.nodes.targets

            rule {
              action = "replace"
              target_label = "__address__"
              replacement = "kubernetes.default.svc.cluster.local:443"
            }

            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              regex = "(.+)"
              action = "replace"
              replacement = "/api/v1/nodes/$${1}/proxy/metrics"
              target_label = "__metrics_path__"
            }
          }

          prometheus.scrape "kubelet" {
            scheme = "https"
            tls_config {
                server_name = "kubernetes"
                ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                insecure_skip_verify = false
            }
            bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
            targets = discovery.relabel.metrics_kubelet.output
            scrape_interval = "15s"
            forward_to = [prometheus.remote_write.mimir.receiver]
          }


          // kube-state-metrics metrics
          //
          discovery.kubernetes "ksm" {
            role = "pod"
            namespaces {
               own_namespace = true
            }
            selectors {
              role  = "pod"
              label = "app.kubernetes.io/component=metrics"
            }
          }
          prometheus.scrape "ksm" {
            targets    = discovery.kubernetes.ksm.targets
            forward_to = [prometheus.remote_write.mimir.receiver]
          }


          // Pod logs
          //
          discovery.kubernetes "pods" {
            role = "pod"
            namespaces {
              own_namespace = false
              names = ["ack-system", "autoscaler", "db-operator-system", "external-secrets", "flux-system", "infra", "keda", "monitoring", "podinfo--staging", "spegel", "stg"]
            }
          }
          discovery.relabel "pods" {
            targets    = discovery.kubernetes.pods.targets

            // namespace is trivial
            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              target_label = "namespace"
            }

            // pod is the name of the pod
            rule {
              source_labels = ["__meta_kubernetes_pod_name"]
              target_label = "pod"
            }

            // container is the name of the container
            rule {
              source_labels = ["__meta_kubernetes_pod_container_name"]
              target_label = "container"
            }

            // app is the "app" label
            rule {
              source_labels = ["__meta_kubernetes_pod_label_app"]
              target_label = "app"
            }
            // name is the "app.kubernetes.io/name" label
            rule {
              source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
              target_label = "name"
            }
          }

          loki.source.kubernetes "kubernetes" {
            targets    = discovery.relabel.pods.output
            forward_to = [loki.process.logs.receiver]
            clustering {
              enabled = true
            }
          }
          loki.process "logs" {
            // stage.json {}
            // stage.labels {}
            // stage.output {
            //  source = "message"
            // }
            forward_to = [loki.echo.debug.receiver, loki.write.loki.receiver]
          }

          // Kubernetes events
          //
          loki.source.kubernetes_events "kubernetes_events" {
            log_format = "json"
            forward_to = [loki.process.kubernetes_events.receiver]
          }
          loki.process "kubernetes_events" {
            stage.json {
              expressions = {
                "kind" = "",
                "name" = "",
                "level" = "",
                "sourcecomponent" = "",
                "sourcehost" = "",
                "output" = "msg",
              }
            }
            stage.labels {
              values = {
                "kind" = "",
                "name" = "",
                "level" = "",
                "sourcecomponent" = "",
                "sourcehost" = "",
              }
            }
            stage.output {
              source = "output"
            }
            forward_to = [loki.write.loki.receiver]
          }

          loki.echo "debug" { }
