---
apiVersion: helm.toolkit.fluxcd.io/v2beta2
kind: HelmRelease
metadata:
  name: alloy

spec:
  interval: 1m
  timeout: 10m
  releaseName: alloy
  chart:
    spec:
      chart: alloy
      version: 0.1.1
      sourceRef:
        kind: HelmRepository
        name: grafana
      interval: 1m
  install:
    remediation:
      retries: 5

  values:
    alloy:
      clustering:
        enabled: true
      configMap:
        content: |-
          logging {
            level = "info"
            format = "logfmt"
          }

          prometheus.remote_write "mimir" {
            endpoint {
              url = "http://mimir-nginx/api/v1/push"
            }
          }

          // node_exporter metrics
          prometheus.exporter.unix "node_stats" { }
          prometheus.scrape "node_stats" {
            targets    = prometheus.exporter.unix.node_stats.targets
            forward_to = [prometheus.remote_write.mimir.receiver]
          }

          // these next examples come from https://medium.com/@stepanvrany/i-replaced-several-kubernetes-components-with-grafana-agent-flow-heres-how-74ecdc60bffe
          discovery.kubernetes "nodes" {
            role = "node"
          }

          // cadvisor
          //
          discovery.relabel "metrics_cadvisor" {
            targets = discovery.kubernetes.nodes.targets

            rule {
              action = "replace"
              target_label = "__address__"
              replacement = "kubernetes.default.svc.cluster.local:443"
            }

            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              regex = "(.+)"
              action = "replace"
              replacement = "/api/v1/nodes/$${1}/proxy/metrics/cadvisor"
              target_label = "__metrics_path__"
            }
          }
          prometheus.scrape "node" {
            scheme = "https"
            tls_config {
                server_name = "kubernetes"
                ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                insecure_skip_verify = false
            }
            bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
            targets = discovery.relabel.metrics_cadvisor.output
            scrape_interval = "15s"
            forward_to = [prometheus.remote_write.mimir.receiver]
          }

          // kubelet
          //
          discovery.relabel "metrics_kubelet" {
            targets = discovery.kubernetes.nodes.targets

            rule {
              action = "replace"
              target_label = "__address__"
              replacement = "kubernetes.default.svc.cluster.local:443"
            }

            rule {
              source_labels = ["__meta_kubernetes_node_name"]
              regex = "(.+)"
              action = "replace"
              replacement = "/api/v1/nodes/$${1}/proxy/metrics"
              target_label = "__metrics_path__"
            }
          }

          prometheus.scrape "kubelet" {
            scheme = "https"
            tls_config {
                server_name = "kubernetes"
                ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                insecure_skip_verify = false
            }
            bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
            targets = discovery.relabel.metrics_kubelet.output
            scrape_interval = "15s"
            forward_to = [prometheus.remote_write.mimir.receiver]
          }


          // kube-state-metrics metrics
          //
          discovery.kubernetes "ksm" {
            role = "pod"
            namespaces {
               own_namespace = true
            }
            selectors {
              role  = "pod"
              label = "app.kubernetes.io/component=metrics"
            }
          }
          prometheus.scrape "ksm" {
            targets    = discovery.kubernetes.ksm.targets
            forward_to = [prometheus.remote_write.mimir.receiver]
          }


          loki.write "loki" {
            endpoint {
              url = "http://loki-gateway/loki/api/v1/push"
            }
          }

          discovery.kubernetes "pods" {
            role = "pod"
          }

          discovery.relabel "logs" {
            targets = discovery.kubernetes.pods.targets

            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              target_label  = "namespace"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_container_name"]
              target_label  = "container"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_name"]
              target_label  = "pod"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_node_name"]
              action = "keep"
              regex = env("HOSTNAME")
            }

            rule {
              source_labels = ["__meta_kubernetes_namespace"]
              action = "drop"
              regex = "grafana-agent"
            }

            rule {
              source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
              target_label  = "__path__"
              separator     = "/"
              replacement   = "/var/log/pods/*$1/*.log"
            }
          }

          local.file_match "logs" {
            path_targets = discovery.relabel.logs.output
          }

          loki.source.file "pods" {
            targets    = local.file_match.logs.targets
            forward_to = [loki.process.logs.receiver]
          }

          loki.process "logs" {
            stage.cri {}
            stage.json {}
            stage.labels {}
            forward_to = [loki.write.loki.receiver]
          }


          loki.source.kubernetes_events "events" {
            log_format = "json"
            forward_to = [loki.write.loki.receiver]
          }
